abstract type AbstractPolynomialVectorBasis{PT<:MP.AbstractPolynomialLike, PV<:AbstractVector{PT}} <: AbstractPolynomialBasis end

MP.monomialtype(::Type{<:AbstractPolynomialVectorBasis{PT}}) where PT = MP.monomialtype(PT)

empty_basis(B::Type{<:AbstractPolynomialVectorBasis{PT, Vector{PT}}}) where PT = B(PT[])
function MP.polynomialtype(basis::AbstractPolynomialVectorBasis{PT}, T::Type) where PT
    C = MP.coefficienttype(PT)
    U = MA.promote_operation(*, C, T)
    V = MA.promote_operation(+, U, U)
    return MP.polynomialtype(PT, V)
end
function MP.polynomial(f::Function, basis::AbstractPolynomialVectorBasis)
    return MP.polynomial(mapreduce(
        ip -> f(ip[1]) * ip[2], MA.add!, enumerate(basis.elements)))
end

function MP.polynomial(Q::AbstractMatrix, basis::AbstractPolynomialVectorBasis,
                       T::Type)
    n = length(basis)
    @assert size(Q) == (n, n)
    return MP.polynomial(mapreduce(row -> basis.elements[row] *
        mapreduce(col -> Q[row, col] * basis.elements[col], MA.add!, 1:n),
        MA.add!, 1:n), T)
end

"""
    struct FixedPolynomialBasis{PT<:MP.AbstractPolynomialLike, PV<:AbstractVector{PT}} <: AbstractPolynomialBasis
        elements::PV
    end

Polynomial basis with the polynomials of the vector `elements`.
For instance, `FixedPolynomialBasis([1, x, 2x^2-1, 4x^3-3x])` is the Chebyshev
polynomial basis for cubic polynomials in the variable `x`.
"""
struct FixedPolynomialBasis{PT<:MP.AbstractPolynomialLike, PV<:AbstractVector{PT}} <: AbstractPolynomialVectorBasis{PT, PV}
    elements::PV
end

function MP.coefficients(p, Basis::Type{<:AbstractPolynomialBasis})
    return MP.coefficients(p, maxdegree_basis(Basis, variables(p), maxdegree(p)); check = false)
end
#=
As `p` is an element of the vector space generated by `basis`, there exist unique coefficients
`coeffs` such that `p = sum(coeffs[a]*a for a in basis)`. Now, when I take `b` in basis of 
highest degree, `c, rem = divrem(p, a)` should return 
`rem = sum(coeffs[a]*a for a in basis if !(a==b))` and `c = p[b]`, 
because `b` does not divide any of the other `a`. To see the last assertion, assume `b` divides 
`a`. Since `b` has maximal degree, `a` has maximal degree, too, and `a = bc` for some constant 
`c`. This however, contradicts that `p` has a unique representation 
`p = sum(coeffs[a]*a for a in basis)`, because
```
p[b]*b+ p[a]*a = p[b]*b + p[a]*b*c = (p[b]+ p[a]*c)*b + 0*a.
```
=#
function MP.coefficients(p, basis::AbstractPolynomialBasis; check = true)
    T = coefficienttype(p)
    coeffs = MA.promote_operation(/, T, T)[] 
    rem = p
    for e in basis
        c, rem = divrem(rem, e)
        @assert maxdegree(c) == 0
        if c != 0
            push!(coeffs, first(coefficients(c)))
        end
    end
    if check
        @assert isapproxzero(rem) "The input polynomial is not in the algebra generated by the input basis."
    end
    return coeffs
end 
